<!DOCTYPE html>
<!-- saved from url=(0080)https://blog.netnerds.net/2015/02/working-with-basic-net-datasets-in-powershell/ -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(
            new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "addRule"
        );
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "insertRule"
        );
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "deleteRule"
        );
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "removeRule"
        );
        const shouldWrapDocStyleSheets =
            location.hostname.endsWith("pushbullet.com") ||
            location.hostname.endsWith("ilsole24ore.com") ||
            location.hostname.endsWith("allegro.pl");
        const documentStyleSheetsDescriptor = shouldWrapDocStyleSheets
            ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets")
            : null;
        const cleanUp = () => {
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "addRule",
                addRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "insertRule",
                insertRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "deleteRule",
                deleteRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "removeRule",
                removeRuleDescriptor
            );
            document.removeEventListener("__darkreader__cleanUp", cleanUp);
            document.removeEventListener(
                "__darkreader__addUndefinedResolver",
                addUndefinedResolver
            );
            if (shouldWrapDocStyleSheets) {
                Object.defineProperty(
                    Document.prototype,
                    "styleSheets",
                    documentStyleSheetsDescriptor
                );
            }
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(
                    new CustomEvent("__darkreader__isDefined", {
                        detail: {tag: e.detail.tag}
                    })
                );
            });
        };
        document.addEventListener("__darkreader__cleanUp", cleanUp);
        document.addEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver
        );
        const updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(
                this,
                rule,
                index
            );
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const docSheets = documentStyleSheetsDescriptor.get.call(this);
            const filtered = [...docSheets].filter((styleSheet) => {
                return !styleSheet.ownerNode.classList.contains("darkreader");
            });
            return Object.setPrototypeOf(filtered, StyleSheetList.prototype);
        }
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "addRule",
            Object.assign({}, addRuleDescriptor, {value: proxyAddRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "insertRule",
            Object.assign({}, insertRuleDescriptor, {value: proxyInsertRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "deleteRule",
            Object.assign({}, deleteRuleDescriptor, {value: proxyDeleteRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "removeRule",
            Object.assign({}, removeRuleDescriptor, {value: proxyRemoveRule})
        );
        if (shouldWrapDocStyleSheets) {
            Object.defineProperty(
                Document.prototype,
                "styleSheets",
                Object.assign({}, documentStyleSheetsDescriptor, {
                    get: proxyDocumentStyleSheets
                })
            );
        }
    })()</script><style class="darkreader darkreader--user-agent" media="screen">input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <style> /* Reset.less
 * Props to Eric Meyer (meyerweb.com) for his CSS reset file. We're using an adapted version here   that cuts out some of the reset HTML elements we will never need here (i.e., dfn, samp, etc).
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
 html,
 body {
   margin: 0;
   padding: 0;
 }
 h1,
 h2,
 h3,
 h4,
 h5,
 h6,
 p,
 blockquote,
 pre,
 a,
 abbr,
 acronym,
 address,
 cite,
 code,
 del,
 dfn,
 em,
 img,
 q,
 s,
 samp,
 small,
 strike,
 strong,
 sub,
 sup,
 tt,
 var,
 dd,
 dl,
 dt,
 li,
 ol,
 ul,
 fieldset,
 form,
 label,
 legend,
 button,
 table,
 caption,
 tbody,
 tfoot,
 thead,
 tr,
 th,
 td {
   margin: 0;
   padding: 0;
   border: 0;
   font-weight: normal;
   font-style: normal;
   font-size: 100%;
   line-height: 1;
   font-family: inherit;
 }
 table {
   border-collapse: collapse;
   border-spacing: 0;
 }
 ol,
 ul {
   list-style: none;
 }
 q:before,
 q:after,
 blockquote:before,
 blockquote:after {
   content: "";
 }
 html {
   overflow-y: scroll;
   font-size: 100%;
   -webkit-text-size-adjust: 100%;
       -ms-text-size-adjust: 100%;
           text-size-adjust: 100%;
 }
 a:focus {
   outline: thin dotted;
 }
 a:hover,
 a:active {
   outline: 0;
 }
 article,
 aside,
 details,
 figcaption,
 figure,
 footer,
 header,
 hgroup,
 nav,
 section {
   display: block;
 }
 audio,
 canvas,
 video {
   display: inline-block;
   *display: inline;
   *zoom: 1;
 }
 audio:not([controls]) {
   display: none;
 }
 sub,
 sup {
   font-size: 75%;
   line-height: 0;
   position: relative;
   vertical-align: baseline;
 }
 sup {
   top: -0.5em;
 }
 sub {
   bottom: -0.25em;
 }
 img {
   border: 0;
   -ms-interpolation-mode: bicubic;
 }
 button,
 input,
 select,
 textarea {
   font-size: 100%;
   margin: 0;
   vertical-align: baseline;
   *vertical-align: middle;
 }
 button,
 input {
   line-height: normal;
   *overflow: visible;
 }
 button::-moz-focus-inner,
 input::-moz-focus-inner {
   border: 0;
   padding: 0;
 }
 button,
 input[type="button"],
 input[type="reset"],
 input[type="submit"] {
   cursor: pointer;
   -webkit-appearance: button;
 }
 input[type="search"] {
   -webkit-appearance: textfield;
   box-sizing: content-box;
 }
 input[type="search"]::-webkit-search-decoration {
   -webkit-appearance: none;
 }
 textarea {
   overflow: auto;
   vertical-align: top;
 }
 *,
 *:before,
 *:after {
   -webkit-font-smoothing: antialiased;
   -moz-osx-font-smoothing: grayscale;
 }
 body {
   padding: 0;
   margin: 10px auto 0 auto;
 }
 .serif {
   font-family: Georgia, Times, serif;
 }
 .iab-ad__wrapper {
   width: 100%;
   max-height: 1090px;
   overflow: hidden;
   margin-top: 10px;
 }
 .text-subheading {
   font-family: "Helvetica Neue", arial, sans-serif;
   font-size: 12px;
   font-weight: 700;
   color: #7f929c;
   color: rgba(0, 39, 59, 0.5);
 }
 .dark-theme .text-subheading {
   color: #eaedee;
   color: rgba(255, 255, 255, 0.85);
 }
 a {
   text-decoration: none;
 }
 .dark-theme {
   background-color: transparent;
   color: #fff;
 }
 body.serif .text-subheading,
 body.serif .video-title,
 body.serif .video-title .branding {
   font-family: Georgia, Times, serif !important;
 }
 .trc_rbox_header {
   display: none !important;
 }
 .ad-dr__title {
   margin-top: 5px;
 }
 .ad-dr__message {
   padding-right: 5px;
 }
 .icon__block {
   margin-bottom: 5px;
 }
 .thumbnails-a .branding {
   font-weight: normal !important;
 }
 .thumbnails-a .videoCube {
   margin-bottom: 1.5% !important;
 }
 .text-links-a .videoCube.thumbnail_none a {
   list-style: none !important;
   margin-left: 0px !important;
 }
 .trc-content-sponsored {
   margin: 0 auto;
 }
 [id^="container-"] {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: fit-content;
  max-width: 700px;
  margin: auto;
}</style><style class="darkreader darkreader--sync" media="screen"></style>

<script src="./loader.js.download" id="tb_loader_script" async="" charset="UTF-8"></script><meta name="darkreader" content="5c73efa121d99432c31435e68e4086fa"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body {
    color: var(--darkreader-neutral-text) !important;
}</style></head>
<body>
    
    <div id="container-bottom">
        <p class="text-subheading icon__block">Sponsored</p>
        
    <div id="ad-container" data-role="ad-container" class="align--center">
        <div id="taboola"></div>
        <script>
            
function has(obj, key) {
    // The object.hasOwnProperty method fails when the
    // property under consideration is named 'hasOwnProperty'.
    return Object.prototype.hasOwnProperty.call(obj, key);
}



/*
 * Iterates over an object or a collection and calls a callback
 * function with each item as a parameter.
 */
function each(collection, callback) {
    var length = collection.length;
    var forEach = Array.prototype.forEach;

    if (isNaN(length)) {
        // Treat collection as an object
        for (var key in collection) {
            if (has(collection, key))
                callback(collection[key], key, collection);
        }
    } else if (forEach) {
        // Treat collection as an array
        forEach.call(collection, callback);
    } else {
        for (var i = 0; i < length; i++)
            callback(collection[i], i, collection);
    }
}

/**
 * Create an object from the key-value pairs in a query string.
 * Duplicate keys are not supported (only last value will be used).
 *
 * @param {string} [queryString] - The search portion of a url. Must start with a ?.
 *                                 Defaults to window.location.search.
 * @returns {Object<string>} - The mapping of query string keys to values.
 */
function parseQueryString(queryString) {
    if (typeof queryString === 'undefined')
        queryString = window.location.search;

    var params = {};

    each(queryString.substr(1).split('&'), function (item) {
        var pair = item.split('=').map(function (part) {
            return decodeURIComponent(part.replace(/\+/g, '%20'));
        });
        if (pair[0])
            params[pair[0]] = pair[1];
    });

    return params;
}


/**
* Wrap a function such that it can only be run once. The return value is cached and returned in subsequent calls.
* @param {function} fn - Function to wrap.
* @returns {any} - Return value as returned by the first invocation of fn, regardless of arguments.
*/
function once(fn) {
    var returnValue;
    return function () {
        if (fn) {
            returnValue = fn.apply(this, arguments);
            fn = null;
        }
        return returnValue;
    };
}

if (window.getComputedStyle) {
    getCurrentStyle = function(elem, prop, _camel) {
        try {
            // We need this to both protect for the case where `elem` is not valid,
            // such as it being `document` and for the broken ShadowDOMPolyfill script.
            // See https://git.io/vrPIf for more details.
            return window.document.defaultView.getComputedStyle(elem, null).getPropertyValue(prop);
        } catch (err) {
            return null;
        }
    };
} else {
    // IE < 9, Opera
    getCurrentStyle = function(elem, prop, camel) {
        return elem.currentStyle[prop] || elem.currentStyle[camel];
    }
}

/**
* Get the height of the document.
*
* @returns {number} - The document height
*/
function getDocumentHeight() {
    const container = document.body;
    var height = container.offsetHeight

    var marginTop = parseInt(getCurrentStyle(container, 'margin-top', 'marginTop'), 10);
    if (marginTop)
        height += marginTop;

    var marginBottom = parseInt(getCurrentStyle(container, 'margin-bottom', 'marginBottom'), 10);
    if (marginBottom)
        height += marginBottom;

    return height;
}

/**
* Starts a loop to notice changes to the page height.
*
* @param {function} cb - Function to call with new height values.
* @returns {void}
*/
function onHeightChange(cb) {
    let count = 0;
    let lastHeight = 0;

    const loop = () => {
        const currentHeight = getDocumentHeight();
        if (currentHeight !== lastHeight) {
            lastHeight = currentHeight;
            cb(currentHeight);
        }

        // We'll watch for height changes for a total of ~25.4 seconds,
        // with these intervals:
        // 100ms, 100ms, 200ms, 200ms, 400ms, 400ms, ..., 6400ms
        // The idea behind these intervals is the following:
        // - on fast websites, with small number of widgets, ad provider
        // will be loaded fast and has good chances to be visible right away,
        // so we need to detect resize quickly
        // - on slow websites it doesn't make sense to check for resize every
        // 100ms because well, they're slow and it might take more than 5sec
        // for ad provider to render. Also most likely page will be long and it
        // will take some time for user to scroll down
        /* eslint-disable no-magic-numbers */
        count += 1;
        if (count < 15)
            setTimeout(loop, 100 * Math.pow(2, Math.floor(count / 2)));
        /* eslint-enable no-magic-numbers */
    };

    loop();
}

/**
* Send a message to the host page. Mimics the format
* used by core/utils/frameBus.
*
* @param {string} name - The event name.
* @param {*} data - JSON-serializable data to send.
* @returns {void}
*/
function sendMessageToHost(name, data) {
    data = data || {};
    window.parent.postMessage(JSON.stringify({
        data,
        name,
        scope: 'host',
        sender:  window.name ,
    }), '*');
}


const POST_MESSAGE_TYPES = Object.freeze({
    click: 'click',
    errorProviderNotReady: 'error-provider-not-ready',
    errorNoHeight: 'error-no-height',
    ready: 'ready',
    resize: 'resize',
    redirect: 'redirect',
});

// The minimum height which indicates an ad has loaded.
// Height of Sponsored text and margin is 32 pixels.
const minHeight = 35;

/**
* Generates events for resizing the frame and ad loads.
*
* @param {Object} options - Options
*   {function} readyData - The data to include with the ready event.
* @returns {function} - A callback which should be called when the provider indicates the ad is ready.
*/
function startAdsLoop(readyData) {
    const startTime = new Date().getTime();

    let providerReadied = false;
    let minHeightReached = false;
    // This parameter isn't expected in the ready event so we delete it after capturing it's value.
    const sendReady = readyData.sendReady;
    delete readyData.sendReady;

    const sendReadyOnce = once(() => {
        const extraData = window._OnReadyExtraData;
        if (extraData) {
            extraData.time_to_load = new Date().getTime() - startTime;
            readyData.extraData = JSON.stringify(extraData);
        }

        sendMessageToHost(POST_MESSAGE_TYPES.ready, readyData);
    });
    const detectReadyMismatch = once(() => {
        setTimeout(() => {
            if (!providerReadied)
                sendMessageToHost(POST_MESSAGE_TYPES.errorProviderNotReady, { provider: readyData.provider });

            const heightReached = minHeightReached || getDocumentHeight() >= minHeight;
            if (!heightReached)
                sendMessageToHost(POST_MESSAGE_TYPES.errorNoHeight, { provider: readyData.provider });
        }, 100); // eslint-disable-line no-magic-numbers
    });

    onHeightChange(height => {
        if (height < minHeight)
            return;

        minHeightReached = true;
        if (sendReady) {
            sendReadyOnce();
        }
        detectReadyMismatch();
        sendMessageToHost(POST_MESSAGE_TYPES.resize, { height });
    });

    return once(() => {
        providerReadied = true;
        detectReadyMismatch();
    });
}

function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

            var doc = window.document;
var head = doc.head || doc.getElementsByTagName('head')[0] || doc.body;

/**
 * Add a style element with the given css.
 *
 * Borrowed from http://stackoverflow.com/a/524721
 *
 * @param {string} css - The css to add
 * @returns {HTMLStyleElement} - The style element which was added
 */
function addStyleSheet(css) {
    var style = doc.createElement('style');

    // type must be set to use `styleSheet.cssText` in legacy IE
    // TODO: Re-examine this once IE8 and IE9 are no longer supported
    style.type = 'text/css';

    if (style.styleSheet)
        style.styleSheet.cssText = css;
    else
        style.appendChild(doc.createTextNode(css));

    head.appendChild(style);

    return style;
}

/**
 * Serializes object containing name:value pairs into a query string.
 *
 * @param {Object} params - The parameters to serialize.
 * @returns {string} - The query string.
 */
function serializeArgs(params) {
    var pcs = [];
    each(params, function (val, key) {
        if (val !== undefined)
            pcs.push(encodeURIComponent(key) + (val === null ? '' : '=' + encodeURIComponent(val)));
    });
    return pcs.join('&');
}

/**
 * Adds name:value pairs from object to the url's query string.
 *
 * @param {string} url - The base url. May already contain a query string.
 * @param {Object} [params] - The parameters to add.
 * @param {boolean} [nocache] - If true, a time-based parameter will be added to bust the cache.
 * @returns {string} - The url with parameters added.
 */
function serialize(url, params, nocache) {
    if (params) {
        if (url.indexOf('?') === -1)
            url += '?';
        else if (url.charAt(url.length - 1) !== '&')
            url += '&';

        url += serializeArgs(params);
    }

    if (nocache) {
        var ncp = {};
        ncp[(new Date()).getTime()] = null;
        return serialize(url, ncp);
    }

    var len = url.length;
    return url.charAt(len - 1) === '&' ? url.slice(0, len - 1) : url;
}


function isString(str) {
    return Object.prototype.toString.call(str) === '[object String]';
}

// Borrowed from underscore
function extend(obj) {
    each(Array.prototype.slice.call(arguments, 1), function (source) {
        for (var prop in source) {
            if (has(source, prop))
                obj[prop] = source[prop];
        }
    });
    return obj;
}

// WARNING: collapsing white space on an input is an XSS hazard.
//
// If you try to pass this function's return value or use this function
// outside of this module, you MUST make it safer.
//
// For more info, see discussion at:
// http://phabricator.local.disqus.net/D22393#inline-161397
function normalizeCssPropertyName(propName) {
    return propName.replace(/\s+/g, '').toLowerCase();
}

// WARNING:
// DOM-modifying function
// Does NOT escape inputs
// XSS hazard
//
// This function does not escape inputs; therefore if you pass outside
// inputs into this function, you open up the code to an XSS attack
// via CSS.
//
// Do NOT pass unknown values into this function!
function setInlineStyle(elem, prop, value) {
    var _styles = {};
    if (isString(prop))
        _styles[prop] = value;
    else
        _styles = prop;

    // Avoid modifying the original object passed into this function
    var styles = extend({}, _styles);

    // - normalize all keys
    //
    // - convert any null values to empty strings
    //   because CSS DOM API in some browsers (probably just IE9)
    //   does not understand null, only empty strings
    //
    // - ignore keys with undefined values
    each(styles, function (val, key) {
        var normalizedKey = normalizeCssPropertyName(key);
        if (normalizedKey !== key) {
            delete styles[key];
            styles[normalizedKey] = val;
        }

        if (val === null)
            styles[normalizedKey] = '';

        if (val === void 0)
            delete styles[normalizedKey];
    });

    var style = elem.style;

    each(styles, function (val, key) {
        // Casting `value` to a string explicitly here since IE9 throws
        // an exception if you pass something else, like a Number
        style.setProperty(key, String(val), 'important');
    });
}

// WARNING: collapsing white space on an input is an XSS hazard.
//
// If you try to pass this function's return value or use this function
// outside of this module, you MUST make it safer.
//
// For more info, see discussion at:
// http://phabricator.local.disqus.net/D22393#inline-161397
function normalize(color) {
    // - remove white space
    // - make lowercase
    return color.replace(/\s+/g, '').toLowerCase();
}

function parseHexColor(color) {
    // if color is exactly 3 hexdigits, expand to 6
    color = color.replace(/^#([a-f0-9])([a-f0-9])([a-f0-9])$/, '#$1$1$2$2$3$3');

    // remove '#'
    color = color.slice(1);

    return {
        red: parseInt(color.slice(0, 2), 16),
        green: parseInt(color.slice(2, 4), 16),
        blue: parseInt(color.slice(4, 6), 16),
    };
}

function parseRgbColor(color) {
    var match = color.match(/^rgb\((\d+),(\d+),(\d+)\)$/);

    return {
        red: parseInt(match[1], 10),
        green: parseInt(match[2], 10),
        blue: parseInt(match[3], 10),
    };
}

function parseRgbaColor(color) {
    var match = color.match(/^rgba\((\d+),(\d+),(\d+),([\d.]+)\)$/);

    return {
        red: parseInt(match[1], 10),
        green: parseInt(match[2], 10),
        blue: parseInt(match[3], 10),
        alpha: parseFloat(match[4]),
    };
}

function getColor(container, elem, color, getColorFunc) {
    elem = window.document.createElement(elem);

    setInlineStyle(elem, {
        visibility: 'hidden',
        color: color,
    });

    container.appendChild(elem);
    color = getColorFunc(elem);
    container.removeChild(elem);

    return color;
}

function parseNamedColor(color, options) {
    options = options || {};
    var container = options.container || window.document.body;

    // We assume `elem.createTextRange` to be available
    // when we don't have `window.getComputedStyle`.
    // This is the case for IE8, which is the only relevant
    // browser that doesn't support getComputedStyle.
    // see http://caniuse.com/#feat=getcomputedstyle
    if (!window.getComputedStyle) {
        color = getColor(container, 'textarea', color, function (elem) {
            // queryCommandValue('ForeColor') returns a 24-bit number
            // in BGR format: [bits 16-23 blue][8-15 green][0-7 red]
            // technique from: http://stackoverflow.com/a/3892864
            return elem.createTextRange().queryCommandValue('ForeColor');
        });
        return {
            red: color & 0x0000FF, // last 8 bits are red
            blue: color >>> 16, // first 8 bits are blue
            green: (color & 0x00FF00) >>> 8, // middle 8 bits are green
        };
    }

    color = getColor(container, 'span', color, function (elem) {
        return window.getComputedStyle(elem, null).getPropertyValue('color');
    });

    return parseRgbColor(normalize(color));
}

// WARNING: this function ASSUMES that its input is a valid CSS color value.
// It DOES NOT attempt to identify and reject invalid inputs.
//
// Example bad input:
//      'rgba(255, 0, 0, 3.2.1)'
//
// If you pass in the above bad input, the resulting behavior of this function
// is unspecified by unit tests.
function parseColor(color, options) {
    color = normalize(color);
    var parseFunc;

    if (color === 'transparent')
        return { red: 0, green: 0, blue: 0, alpha: 0 };

    // if color starts with '#'
    if (color.charAt(0) === '#')
        parseFunc = parseHexColor;

    // if color starts with 'rgba'
    else if (color.slice(0, 5) === 'rgba(')
        parseFunc = parseRgbaColor;

    // if color starts with 'rgb'
    else if (color.slice(0, 4) === 'rgb(')
        parseFunc = parseRgbColor;

    // if color is only alpha chars
    else if (/^[a-z]+$/.test(color))
        parseFunc = parseNamedColor;

    else
        throw new Error('parseColor received unparseable color: ' + color);

    return parseFunc(color, options);
}


var ERROR_REASON = 'Color components should be numbers.';

function toRGBColorString(components) {
    var red = Number(components.red);
    var green = Number(components.green);
    var blue = Number(components.blue);

    // Since this function produces a string ready to inject into CSS,
    // do the following checks to guard against XSS
    if (isNaN(red) || isNaN(green) || isNaN(blue))
        throw new Error(ERROR_REASON);

    var prefix = 'rgb';
    var colors = [red, green, blue];

    // alpha component is optional
    var alpha = components.alpha;
    if (alpha) {
        alpha = Number(alpha);
        if (isNaN(alpha))
            throw new Error(ERROR_REASON);
        prefix += 'a';
        colors.push(alpha);
    }

    return prefix + '(' + colors + ')';
}

const DEFAULT_WIDGET_ID = 'disqus-widget-safetylevel20longtail09';

/**
 * Taboola class for initializing and loading Taboola content. Extends BaseProvider class.
 */
class Taboola {
    /**
     * Constructs a new Taboola class calling BaseProvider constructor and registering script URL, handlers, and styles.
     * @param {Object} props - Data specific to Taboola.
     * @param {string} props.taboola_publisher_name - The named Taboola publisher name
     * @param {string} props.script_path - The override Taboola publisher name
     * @param {string} props.fallback_script_path - The Taboola publisher name to fallback to.
     * @param {string} props.colorScheme - The color scheme of the host page.
     * @param {string} props.anchorColor - The link color of the host page in hexadecimal format.
     * @param {string} props.mode - The Taboola ad mode.
     * @param {string} props.source_url - The absolute URL of the host page.
     * @param {string} props.referrer_url - The absolute URL of the referring page.
     * @param {string} props.placement - The Taboola placement of the ad.
     * @param {Object} callbacks - Taboola lifecycle callback handlers.
     * @param {function} callbacks.onScriptLoad - onScriptLoad callback handler when Taboola tag loads.
     * @param {function} callbacks.onAdLoad - onAdLoad callback handler when Taboola renders an ad.
     * @param {function} callbacks.onAdError - onAdError callback handler when Taboola returns no content.
     * @param {function} callbacks.onClick - onClick callback handler when user clicks on a Taboola ad.
     */
    constructor(props, callbacks) {
        this.props = props;
        this.callbacks = callbacks;
        this._taboola = window._taboola = window._taboola || [];
        this.taboolaPublisherId = props.script_path || props.taboola_publisher_name;

        this.setStyles();
        this.setPageType();
        this.addWidget();
        this.registerListeners();

        // Ensure all event handlers are bound to the class since their
        // context may change depending on where they're bound.
        this.onScriptLoad = this.onScriptLoad.bind(this);
        this.onAdLoad = this.onAdLoad.bind(this);
        this.onAdError = this.onAdError.bind(this);
        this.onClick = this.onClick.bind(this);
    }

    /**
     * Sets document styles necessary for Taboola.
     *
     * @param {Element} element - The parent element of the ad container.
     */
    setStyles(element = window.document.body) {
        if (this.props.typeface === 'serif')
            element.className += ' serif';

        if (this.props.colorScheme === 'dark')
            element.className += ' dark-theme';

        if (this.props.anchorColor) {
            // WARNING: Must parse then stringify to prevent XSS
            const color = toRGBColorString(parseColor(this.props.anchorColor));
            addStyleSheet(`a, .video-title { color: ${color} !important; }`);
        }
    }

    /**
     * Adds the page type to the Taboola queue.
     */
    setPageType() {
        this._taboola.push({
            article: 'auto',
            url: this.props.source_url,
            referrer: this.props.referrer_url,
        });
    }

    /**
     * Adds the widget arguments to the Taboola queue.
     */
    addWidget() {
        this._taboola.push({
            mode: this.props.mode,
            container: 'taboola',
            target_type: 'mix',
            placement: this.props.placement,
        });
    }

    /**
     * Registers callback event handlers for ad lifecycle events from Taboola.
     */
    registerListeners() {
        this._taboola.push({
            listenTo: 'render',
            handler: () => {
                this.onAdLoad();
            },
        });

        this._taboola.push({
            listenTo: 'nocontent',
            handler: () => {
                const scriptPath = this.taboolaPublisherId;
                const fallbackScriptPath = this.props.fallback_script_path || DEFAULT_WIDGET_ID;
                /** We've found that Taboola has a large number of "placements" misconfigured on their side.
                 *  Rather than going through them manually, we're trying to create a fallback approach
                 *  (and they can look at the data on their side to repair). */
                if (scriptPath !== fallbackScriptPath && !this.props.script_path)
                    window.location.replace(`${window.location.href}&script_path=${fallbackScriptPath}`);
                else
                    this.onAdError(POST_MESSAGE_TYPES.errorProviderNotReady);
            },
        });

        this._taboola.push({
            listenTo: 'click',
            handler: () => {
                this.onClick();
            },
        });
    }

    /**
     * Loads the Taboola script tag and pushes the "flush" command telling Taboola to load ads.
     */
    load() {
        var script = doc.createElement('script');
        script.src = serialize(
            `https://cdn.taboola.com/libtrc/${this.taboolaPublisherId}/loader.js`,
            undefined,
            undefined,
        );
        script.id = 'tb_loader_script';
        script.async = true;
        script.charset = 'UTF-8';
        script.onload = this.onScriptLoad;
        head.appendChild(script);

        // Sending the flush command tells Taboola there are no
        // additional widgets and should make the request now.
        this._taboola.push({
            flush: true,
        });
    }

    /**
     * Event handler for when the script tag finishes loading.
     */
    onScriptLoad() {
        this.fireCallback('onScriptLoad');
    }

    /**
     * Event handler for when the ad loads a creative.
     */
    onAdLoad() {
        this.fireCallback('onAdLoad');
    }

    /**
     * Event handler for when the ad returns an error.
     * @param {string} reason - The reason ID for the error.
     */
    onAdError(reason) {
        this.fireCallback('onAdError', reason);
    }

    /**
     * Event handler for when the user clicks on an ad.
     */
    onClick() {
        this.fireCallback('onClick');
    }

    /**
     * Looks up registered callbacks and calls their handler if found.
     * @param {string} name - The name of the callback.
     * @param {...any} args - The arguments supplied
     */
    fireCallback(name, ...args) {
        if (this.callbacks[name])
            this.callbacks[name].apply(this, args);
    }
}


const iframeTemplateData = {"placement":"{\"domain\": \"https://blog.netnerds.net\", \"experiment\": \"network_default\", \"position\": \"bottom\", \"shortname\": \"netnerds\", \"variant\": \"fallthrough\"}","is_taboola_named":false,"language":"en","colorscheme":"dark","typeface":"sans-serif","variant":"fallthrough","forum_id":6342890,"source_url":"https://blog.netnerds.net/2015/02/working-with-basic-net-datasets-in-powershell/","organization_id":4543150,"taboola_publisher_name":"disqus-widget-safetylevel20longtail09","experiment":"network_default","mode":"thumbnails-b","position":"bottom","shortname":"netnerds","referrer_url":"https://blog.netnerds.net/","canonical_url":"https://blog.netnerds.net/2015/02/working-with-basic-net-datasets-in-powershell/"};
const queryParams = parseQueryString(window.location.search);

const taboola = new Taboola({ ...iframeTemplateData, ...queryParams }, {
    onAdLoad: startAdsLoop({
        advertisement_id: 184193,
        forumId: iframeTemplateData.forum_id,
        provider: 'taboola',
        sendReady: true,
    }),
    onAdError: errorReason => sendMessageToHost(errorReason, {provider: 'taboola'}),
    onClick: () => sendMessageToHost(POST_MESSAGE_TYPES.click, {provider: 'taboola'}),
});

taboola.load();

        </script>
    </div>

    </div>



</body></html>