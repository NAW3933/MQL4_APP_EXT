/*
   Generated by ex4-to-mq4 decompiler FREEWARE 4.0.451.5
   Website: HtTp : / /W WW .m e tA q U otEs. n e t
   E-mail :  S u P POR T @ mE TAQ Uo t es.n E T
*/
#property copyright "Copyright © 2008, FOREXflash Software Corp."
#property link      "http://www.metaquotes.net"

#property indicator_chart_window
#property indicator_buffers 7
#property indicator_color1 Black
#property indicator_color2 Black
#property indicator_color3 Black
#property indicator_color4 Black
#property indicator_color5 Black
#property indicator_color6 Black
#property indicator_color7 Black

extern bool ShowText = TRUE;
extern int MA_Length = 100;
extern int ShiftUpText = 0;
extern int ShiftDownText = 0;
extern int SizeText = 7;
extern int AngleText = 90;
int Gi_100 = 500;
double G_ibuf_104[];
double G_ibuf_108[];
double G_ibuf_112[];
double G_ibuf_116[];
double G_ibuf_120[];
double G_ibuf_124[];
double G_ibuf_128[];
string Gs_unused_132;
int Gi_140 = 1;
double Gd_144;
double Gd_152;

int init() {
  string Ls_0 = "2030.06.12";
  int str2time_8 = StrToTime(Ls_0);
 if (TimeCurrent() >= str2time_8) {
      Alert("The trial version expired! Contact forexflash@gmail.com");
      return (1);//
   }
   SetIndexBuffer(0, G_ibuf_104);
   SetIndexStyle(0, DRAW_NONE);
   SetIndexBuffer(1, G_ibuf_108);
   SetIndexStyle(1, DRAW_NONE);
   SetIndexBuffer(2, G_ibuf_112);
   SetIndexStyle(2, DRAW_NONE);
   SetIndexBuffer(3, G_ibuf_116);
   SetIndexStyle(3, DRAW_NONE);
   SetIndexBuffer(4, G_ibuf_120);
   SetIndexStyle(4, DRAW_NONE);
   SetIndexBuffer(5, G_ibuf_124);
   SetIndexStyle(5, DRAW_NONE);
   SetIndexBuffer(6, G_ibuf_128);
   SetIndexStyle(6, DRAW_NONE);
   string Ls_12 = "VSA© BARdots";
   IndicatorShortName(Ls_12);
   Gs_unused_132 = Ls_12;
   IndicatorDigits(1);
   Gd_144 = ShiftUpText * Point;
   Gd_152 = ShiftDownText * Point;
   return (1);
}

int deinit() {
   datetime time_0;
   string name_4;
   for (int index_12 = 0; index_12 < Bars; index_12++) {
      time_0 = Time[index_12];
      name_4 = "NDS_" + time_0;
      if (ObjectFind(name_4) >= 0) ObjectDelete(name_4);
      name_4 = "Suppl_" + time_0;
      if (ObjectFind(name_4) >= 0) ObjectDelete(name_4);
   }
   return (0);
}

int start() {
   AVGSpread();
   AVGVolume();
   return (0);
}

int AVGSpread() {
   int Li_8 = IndicatorCounted();
   if (Li_8 > 0) Li_8--;
   int Li_4 = Bars - Li_8;
   for (int Li_0 = 0; Li_0 < Li_4; Li_0++) G_ibuf_108[Li_0] = (iHigh(NULL, 0, Li_0) - iLow(NULL, 0, Li_0)) / Point / Gi_140;
   for (Li_0 = 0; Li_0 < Li_4; Li_0++) G_ibuf_112[Li_0] = iMAOnArray(G_ibuf_108, 0, MA_Length, 0, MODE_EMA, Li_0);
   return (0);
}

int AVGVolume() {
   double Ld_0;
   double Ld_24;
   double Ld_32;
   double Ld_40;
   double Ld_48;
   double Ld_56;
   int Li_12 = IndicatorCounted();
   if (Li_12 > 0) Li_12--;
   if (Gi_100 == 0) Gi_100 = Bars - Li_12;
   int Li_8 = Gi_100;
   for (int Li_16 = 0; Li_16 < Li_8; Li_16++) {
      Ld_0 = 0;
      for (int Li_20 = Li_16; Li_20 < Li_16 + MA_Length; Li_20++) Ld_0 = Volume[Li_20] + Ld_0;
      G_ibuf_124[Li_16] = NormalizeDouble(Ld_0 / MA_Length, 0);
      G_ibuf_128[Li_16] = iVolume(NULL, 0, Li_16);
      Ld_24 = (High[Li_16 + 1] + (Low[Li_16 + 1])) / 2.0;
      Ld_32 = (High[Li_16 + 1] + (Low[Li_16 + 1])) / 2.0 + (High[Li_16 + 1] - (Low[Li_16 + 1])) / 3.3;
      Ld_40 = (High[Li_16 + 1] + (Low[Li_16 + 1])) / 2.0 - (High[Li_16 + 1] - (Low[Li_16 + 1])) / 3.3;
      Ld_48 = (High[Li_16 + 2] + (Low[Li_16 + 2])) / 2.0 + (High[Li_16 + 2] - (Low[Li_16 + 2])) / 3.3;
      Ld_56 = (High[Li_16 + 2] + (Low[Li_16 + 2])) / 2.0 - (High[Li_16 + 2] - (Low[Li_16 + 2])) / 3.3;
      if (High[Li_16 + 1] > High[Li_16 + 2] && G_ibuf_108[Li_16 + 1] > 1.8 * (G_ibuf_112[Li_16 + 1]) && Close[Li_16 + 1] < Ld_56 && G_ibuf_128[Li_16 + 1] > G_ibuf_128[Li_16 +
         2] && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 1, Li_16 + 1);
      if (High[Li_16 + 1] > High[Li_16 + 2] && G_ibuf_108[Li_16 + 1] > 1.8 * (G_ibuf_112[Li_16 + 1]) && Close[Li_16 + 1] < Ld_56 && G_ibuf_128[Li_16 + 1] > G_ibuf_128[Li_16 +
         2] && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 2, Li_16 + 1);
      if (High[Li_16 + 1] > High[Li_16 + 2] && G_ibuf_108[Li_16 + 1] > 1.8 * (G_ibuf_112[Li_16 + 1]) && Close[Li_16 + 1] > Ld_56 && Close[Li_16 + 1] < Ld_48 && G_ibuf_128[Li_16 +
         1] > G_ibuf_128[Li_16 + 2] && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 3, Li_16 + 1);
      if (High[Li_16 + 1] > High[Li_16 + 2] && G_ibuf_108[Li_16 + 1] < G_ibuf_112[Li_16 + 1] && Close[Li_16 + 1] < Ld_56 && G_ibuf_128[Li_16 + 1] > G_ibuf_128[Li_16 + 2] &&
         G_ibuf_128[Li_16 + 1] < G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 4, Li_16 + 1);
      if (Close[Li_16 + 1] > Close[Li_16 + 2] && Close[Li_16 + 1] < Ld_24 && G_ibuf_108[Li_16 + 1] < 0.8 * (G_ibuf_112[Li_16 + 1]) && G_ibuf_128[Li_16 + 1] < G_ibuf_124[Li_16 +
         1]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 5, Li_16 + 1);
      if (Close[Li_16 + 1] > Close[Li_16 + 2] && Close[Li_16 + 1] > Ld_32 && G_ibuf_108[Li_16 + 1] > 1.5 * (G_ibuf_112[Li_16 + 1]) && G_ibuf_128[Li_16 + 1] > G_ibuf_128[Li_16 +
         2]) TextOutput(Li_16, High[Li_16 + 1] + Gd_144, 6, Li_16 + 1);
      if (Close[Li_16 + 1] > Close[Li_16 + 2] && Close[Li_16 + 1] < Ld_24 && G_ibuf_108[Li_16 + 1] > 1.5 * (G_ibuf_112[Li_16 + 1]) && G_ibuf_128[Li_16 + 1] > G_ibuf_128[Li_16 +
         2] && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, Low[Li_16 + 1] - Gd_144, 7, Li_16 + 1);
      if (Close[Li_16 + 1] < Close[Li_16 + 2] && Close[Li_16 + 1] > Ld_48 && G_ibuf_128[Li_16 + 1] < G_ibuf_128[Li_16 + 2] && G_ibuf_128[Li_16 + 1] < G_ibuf_124[Li_16 +
         1]) TextOutput(Li_16, Low[Li_16 + 1] - Gd_144, 8, Li_16 + 1);
      if (Close[Li_16 + 1] < Close[Li_16 + 2] && Close[Li_16 + 1] > Ld_24 && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, Low[Li_16 + 1] - Gd_144, 9, Li_16 + 1);
      if (Close[Li_16 + 1] > Close[Li_16 + 2] && Close[Li_16 + 1] > Ld_24 && Low[Li_16 + 1] < Low[Li_16 + 2] && Low[Li_16 + 2] < Low[Li_16 + 3] && G_ibuf_108[Li_16 + 1] > 1.5 * (G_ibuf_112[Li_16 +
         1]) && G_ibuf_128[Li_16 + 1] > G_ibuf_124[Li_16 + 1]) TextOutput(Li_16, Low[Li_16 + 1] - Gd_144, 10, Li_16 + 1);
      if (Close[Li_16 + 1] < Close[Li_16 + 2] && Close[Li_16 + 1] < Ld_24 && G_ibuf_108[Li_16 + 1] < 0.8 * (G_ibuf_112[Li_16 + 1]) && G_ibuf_128[Li_16 + 1] < G_ibuf_124[Li_16 +
         1]) TextOutput(Li_16, Low[Li_16 + 1] - Gd_144, 11, Li_16 + 1);
   }
   return (0);
}

void TextOutput(int Ai_0, double A_price_4, int Ai_12, int Ai_16) {
   string text_32;
   int time_20 = Time[Ai_0 + 1];
   string name_24 = "NDS_" + time_20;
   if (ObjectFind(name_24) >= 0) ObjectDelete(name_24);
   ObjectCreate(name_24, OBJ_TEXT, 0, time_20, A_price_4);
   ObjectSet(name_24, OBJPROP_ANGLE, AngleText);
   if (Ai_12 == 1) {
      text_32 = "UPTHRUST / Weakness_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 2) {
      text_32 = "HV UPTHRUST / Weakness_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 3) {
      text_32 = "LOW UPTHRUST / Demand stronger_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 4) {
      text_32 = "PSEUDO UPTHRUST / Weakness_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 5) {
      text_32 = "NO DEMAND / Weakness_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 6) {
      text_32 = "MARK UP / Strenght_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 7) {
      text_32 = "FAILED MARK UP / Weakness_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 8) {
      text_32 = "TESTING FOR SUPPLY / Strenght_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 9) {
      text_32 = "STOPPING VOLUME / Strenght_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 10) {
      text_32 = "REVERSE UPTHRUST / Strenght_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
   if (Ai_12 == 11) {
      text_32 = "NO SUPPLY / Strenght_" + Ai_16;
      ObjectSetText(name_24, text_32, SizeText, "Tahoma", White);
   }
}